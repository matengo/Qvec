using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Qvec.SourceGen
{
    [Generator]
    public class QvecFieldExtractorGenerator : IIncrementalGenerator
    {
        private const string QvecIndexedAttribute = "Qvec.Core.QvecIndexedAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all properties with [QvecIndexed], grouped by containing type
            var indexedProperties = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    QvecIndexedAttribute,
                    predicate: static (node, _) => node is PropertyDeclarationSyntax,
                    transform: static (ctx, _) =>
                    {
                        var property = (IPropertySymbol)ctx.TargetSymbol;
                        var containingType = property.ContainingType;
                        return new IndexedPropertyInfo(
                            TypeNamespace: containingType.ContainingNamespace.IsGlobalNamespace
                                ? ""
                                : containingType.ContainingNamespace.ToDisplayString(),
                            TypeName: containingType.Name,
                            TypeFullName: containingType.ToDisplayString(),
                            PropertyName: property.Name);
                    })
                .Collect();

            context.RegisterSourceOutput(indexedProperties, static (spc, properties) =>
            {
                if (properties.IsDefaultOrEmpty) return;

                // Group by full type name
                var grouped = properties.GroupBy(p => p.TypeFullName);

                foreach (var group in grouped)
                {
                    var first = group.First();
                    var props = group.Select(g => g.PropertyName).Distinct().ToArray();
                    var source = GenerateExtractor(first.TypeNamespace, first.TypeName, first.TypeFullName, props);
                    spc.AddSource($"{first.TypeName}FieldExtractor.g.cs", SourceText.From(source, Encoding.UTF8));
                }
            });
        }

        private static string GenerateExtractor(string ns, string typeName, string typeFullName, string[] properties)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Qvec.Core;");
            sb.AppendLine();

            var extractorNs = string.IsNullOrEmpty(ns) ? "Qvec.Generated" : ns;
            sb.AppendLine($"namespace {extractorNs}");
            sb.AppendLine("{");
            sb.AppendLine($"    public sealed class {typeName}FieldExtractor : IQvecFieldExtractor<{typeFullName}>");
            sb.AppendLine("    {");
            sb.AppendLine($"        public IEnumerable<(string Field, string Value)> ExtractFields({typeFullName} item)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (item == null) yield break;");

            foreach (var prop in properties)
            {
                sb.AppendLine($"            yield return (\"{prop}\", item.{prop}?.ToString());");
            }

            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private record struct IndexedPropertyInfo(
            string TypeNamespace,
            string TypeName,
            string TypeFullName,
            string PropertyName);
    }
}
